# Debug Tool & SwiftDebugFloatingButton

swift_flutter includes a powerful debug tool that helps you monitor network requests, WebSocket connections, and logs during development. This chapter will show you how to set it up and use it effectively.

## Overview

The debug tool provides:

- **Network Interceptor** - Automatically captures all HTTP requests
- **WebSocket Interceptor** - Tracks WebSocket connections and messages
- **Log Interceptor** - Captures print statements and logs
- **Curl Generator** - Generates curl commands for API testing
- **Modern UI** - Beautiful, responsive debug inspector interface

## Enabling the Debug Tool

### Step 1: Initialize in main()

Enable the debug tool with a single line in your `main()` function:

```dart
import 'package:swift_flutter/swift_flutter.dart';

void main() {
  // Enable debug tool
  SwiftFlutter.init(debugtool: true);
  runApp(MyApp());
}
```

### Step 2: Add SwiftDebugFloatingButton

**⚠️ IMPORTANT**: You must add `SwiftDebugFloatingButton` to your `Scaffold` to access the debug inspector page. Without it, you won't be able to view captured network requests, logs, or WebSocket connections.

```dart
import 'package:swift_flutter/swift_flutter.dart';

class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('My App'),
      ),
      body: Center(
        child: Text('Hello World'),
      ),
      // Add SwiftDebugFloatingButton to access debug inspector
      floatingActionButton: const SwiftDebugFloatingButton(),
    );
  }
}
```

The floating button will automatically appear when the debug tool is enabled and provides one-tap access to the debug inspector.

## Complete Setup Example

Here's a complete example showing the full setup:

```dart
import 'package:flutter/material.dart';
import 'package:swift_flutter/swift_flutter.dart';
import 'package:http/http.dart' as http;

void main() {
  // Initialize with debug tool enabled
  SwiftFlutter.init(debugtool: true);
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Debug Tool Demo',
      theme: ThemeData(primarySwatch: Colors.blue),
      home: const HomePage(),
    );
  }
}

class HomePage extends StatelessWidget {
  const HomePage({super.key});

  Future<void> _makeRequest() async {
    // HTTP requests are automatically intercepted
    final response = await SwiftHttpHelper.intercept(
      () => http.get(Uri.parse('https://jsonplaceholder.typicode.com/posts/1')),
      method: 'GET',
      url: 'https://jsonplaceholder.typicode.com/posts/1',
    );
    
    print('Response status: ${response.statusCode}');
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Debug Tool Demo'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            ElevatedButton(
              onPressed: _makeRequest,
              child: const Text('Make API Request'),
            ),
            const SizedBox(height: 20),
            const Text(
              'Tap the floating button to view\ncaptured network requests',
              textAlign: TextAlign.center,
              style: TextStyle(color: Colors.grey),
            ),
          ],
        ),
      ),
      // ⚠️ REQUIRED: Add SwiftDebugFloatingButton to access debug inspector
      floatingActionButton: const SwiftDebugFloatingButton(),
    );
  }
}
```

## Debug Inspector Features

Once you tap the `SwiftDebugFloatingButton`, you'll see the debug inspector with four tabs:

### 1. HTTP Tab

View all HTTP requests with:
- Request method, URL, headers, and body
- Response status code, headers, and body
- Request duration
- Color-coded status indicators (green for success, red for errors)

### 2. WebSocket Tab

Monitor WebSocket connections:
- Connection status (connected/disconnected)
- Messages sent and received
- Connection errors
- Event timeline

### 3. Logs Tab

Browse captured logs:
- All `swiftPrint()` calls
- Standard print statements
- Log types (print, debug, info, warning, error)
- Timestamps for each log entry

### 4. Curl Tab

Copy curl commands:
- Automatically generated curl commands for each request
- Ready to paste into terminal for testing
- Includes all headers and body data

## Using Network Interceptor

### With http Package

```dart
import 'package:http/http.dart' as http;
import 'package:swift_flutter/swift_flutter.dart';

// Wrap your http calls with SwiftHttpHelper.intercept()
final response = await SwiftHttpHelper.intercept(
  () => http.get(Uri.parse('https://api.example.com/data')),
  method: 'GET',
  url: 'https://api.example.com/data',
);

// POST request
final postResponse = await SwiftHttpHelper.intercept(
  () => http.post(
    Uri.parse('https://api.example.com/posts'),
    headers: {'Content-Type': 'application/json'},
    body: '{"title":"Test"}',
  ),
  method: 'POST',
  url: 'https://api.example.com/posts',
  body: {'title': 'Test'},
  headers: {'Content-Type': 'application/json'},
);
```

### With Dio Package

Dio requests are automatically intercepted when you configure Dio with an interceptor:

```dart
import 'package:dio/dio.dart';
import 'package:swift_flutter/swift_flutter.dart';

final dio = Dio();

// Setup Dio interceptor to capture requests
dio.interceptors.add(InterceptorsWrapper(
  onRequest: (options, handler) {
    if (NetworkInterceptor.isEnabled) {
      final requestId = NetworkInterceptor.captureRequest(
        method: options.method,
        url: options.uri.toString(),
        headers: options.headers.map((key, value) => 
          MapEntry(key, value.toString())),
        body: options.data,
      );
      options.extra['swift_debug_id'] = requestId;
    }
    handler.next(options);
  },
  onResponse: (response, handler) {
    if (NetworkInterceptor.isEnabled && 
        response.requestOptions.extra.containsKey('swift_debug_id')) {
      final requestId = response.requestOptions.extra['swift_debug_id'] as String;
      NetworkInterceptor.captureResponse(
        requestId: requestId,
        statusCode: response.statusCode,
        headers: response.headers.map.map((key, value) => 
          MapEntry(key, value.join(', '))),
        body: response.data,
      );
    }
    handler.next(response);
  },
  onError: (error, handler) {
    if (NetworkInterceptor.isEnabled && 
        error.requestOptions.extra.containsKey('swift_debug_id')) {
      final requestId = error.requestOptions.extra['swift_debug_id'] as String;
      NetworkInterceptor.captureResponse(
        requestId: requestId,
        statusCode: error.response?.statusCode,
        headers: error.response?.headers.map.map((key, value) => 
          MapEntry(key, value.join(', '))) ?? {},
        body: {'error': error.message, 'type': error.type.toString()},
      );
    }
    handler.next(error);
  },
));

// Now all Dio requests are automatically captured
final response = await dio.get('https://api.example.com/data');
```

## Using Log Interceptor

Use `swiftPrint()` instead of `print()` to capture logs:

```dart
import 'package:swift_flutter/swift_flutter.dart';

// This will appear in the debug tool's Logs tab
swiftPrint('User logged in');
swiftPrint('API call started', data: {'endpoint': '/users'});

// You can also use different log types
LogInterceptor.captureLog(
  'Debug message',
  type: LogType.debug,
  data: {'key': 'value'},
);
```

## Production Considerations

**Always disable the debug tool in production builds:**

```dart
import 'package:flutter/foundation.dart';
import 'package:swift_flutter/swift_flutter.dart';

void main() {
  // Only enable in debug mode
  SwiftFlutter.init(debugtool: kDebugMode);
  runApp(MyApp());
}
```

This ensures:
- Zero overhead in production
- No network interception in release builds
- Better performance
- Smaller app size

## Best Practices

1. **Enable Only in Development**
   ```dart
   SwiftFlutter.init(debugtool: kDebugMode);
   ```

2. **Always Add the Floating Button**
   - Don't forget to add `SwiftDebugFloatingButton` to your Scaffold
   - Without it, you can't access the debug inspector

3. **Use swiftPrint() for Important Logs**
   - Replace `print()` with `swiftPrint()` for logs you want to track
   - Use appropriate log types (debug, info, warning, error)

4. **Monitor Network Requests**
   - Use the HTTP tab to debug API issues
   - Check request/response headers and bodies
   - Copy curl commands for testing

5. **Track WebSocket Connections**
   - Monitor real-time connections in the WebSocket tab
   - Check message flow and connection status
   - Debug connection errors

## Troubleshooting

### Floating Button Not Appearing

If the floating button doesn't appear:
1. Check that `SwiftFlutter.init(debugtool: true)` is called
2. Verify `SwiftDebugFloatingButton` is added to Scaffold
3. Ensure the debug tool is enabled before building the widget

### Requests Not Captured

If network requests aren't being captured:
1. Make sure you're using `SwiftHttpHelper.intercept()` for http package
2. For Dio, ensure the interceptor is properly configured
3. Check that `NetworkInterceptor.isEnabled` is true

### Logs Not Showing

If logs aren't appearing:
1. Use `swiftPrint()` instead of `print()`
2. Check that `LogInterceptor.isEnabled` is true
3. Verify logs aren't being cleared

## Summary

The debug tool is an essential part of swift_flutter that helps you:
- Monitor network requests in real-time
- Track WebSocket connections and messages
- Capture and review logs
- Generate curl commands for API testing

**Remember**: Always add `SwiftDebugFloatingButton` to your Scaffold to access the debug inspector!

---

**Previous**: [Reactive State ←](03_reactive_state.md) | **Next**: [Computed Values →](04_computed_values.md)

